[
  {
    "title": "DB-Verbindungen: Pooling, robuste Fehlerbehandlung und Migrationspfad",
    "prompt": "Ziel: Stabileren DB-Zugriff sicherstellen.\n\nAufgaben:\n- Prüfe src/db/ und src/db_config.py: Implementiere Connection-Pooling (z.B. psycopg2.pool oder SQLAlchemy Engine).\n- Füge Retry bei transienten Fehlern hinzu.\n- Füge einfache Migrationen hinzu (z.B. Alembic) oder dokumentiere Migrationslauf.\n- Ergänze Health/Readiness um DB-Ping.\n\nAkzeptanzkriterien:\n- Langlebige Prozesse leaken keine Connections.\n- Simulierte DB-Neustarts werden abgefangen (Reconnect)."
  },
  {
    "title": "Graceful Shutdown und Signalhandling vervollständigen",
    "prompt": "Ziel: Der Agent beendet laufende Arbeiten kontrolliert bei SIGTERM/SIGINT.\n\nAufgaben:\n- Integriere die vorhandenen Signal-Handler in den Flask-Lebenszyklus oder den Main-Loop.\n- Sicherstellen, dass neue Tasks gestoppt werden, laufende Schritte zu Ende geführt werden.\n- Ressourcen sauber schließen (DB/HTTP).\n\nAkzeptanzkriterien:\n- Container-Stop führt zu geordnetem Shutdown und konsistentem Status."
  },
  {
    "title": "Observability: Prometheus-Metriken und optionale Traces",
    "prompt": "Ziel: Betriebsmetriken verfügbar machen.\n\nAufgaben:\n- Integriere prometheus_client und stelle /metrics bereit.\n- Metriken: task_received_total, task_completed_total, task_failed_total, http_request_duration_seconds nach Ziel, llm_call_duration_seconds, retries_total.\n- Optional: OpenTelemetry-Hooks für HTTP und DB (abschaltbar).\n\nAkzeptanzkriterien:\n- Metriken sind im Betrieb abrufbar; Basis-Grafana-Dashboard beschrieben."
  },
  {
    "title": "Input/Output-Validierung und defensive Programmierung",
    "prompt": "Ziel: Stabilität durch Schema-Validierung erhöhen.\n\nAufgaben:\n- Definiere Pydantic-Modelle für Controller-Responses (Tasks), LLM-Responses und eigene API-Payloads.\n- Validiere eingehende Daten strikt; bei Fehlern sauber loggen + Task in Fehlerstatus mit Grund setzen.\n\nAkzeptanzkriterien:\n- Unerwartete Felder/Typen führen nicht zu Crashes, sondern zu klaren Fehlermeldungen."
  },
  {
    "title": "Fehlerstrategie und einheitliche Exception-Handling-Middleware",
    "prompt": "Ziel: Klare Fehlerklassifikation (transient vs. permanent) und einheitliche Behandlung.\n\nAufgaben:\n- Erstelle Fehlerklassen (TransientError, PermanentError).\n- Mapping: HTTP 5xx/Timeout -> Transient (mit Retry), 4xx valider Fehler -> Permanent.\n- Fange Ausnahmen zentral ab, logge strukturiert mit Ursache und Korrelation-ID.\n\nAkzeptanzkriterien:\n- Wiederholbare Fehler werden automatisch erneut versucht; permanente werden dokumentiert."
  },
  {
    "title": "Security: Secrets-Handling, Rate Limiting und Dependency-Scanning",
    "prompt": "Ziel: Basis-Security-Härte.\n\nAufgaben:\n- Lade Secrets nur aus ENV/Secret-Store; verhindere Log-Ausgabe sensibler Werte.\n- Implementiere einfaches Rate-Limiting auf kritischen Endpoints (falls extern exponiert).\n- Füge Safety Checks in CI (pip-audit, bandit).\n\nAkzeptanzkriterien:\n- Keine Secrets in Logs/Artefakten.\n- CI bricht bei bekannten kritischen CVEs."
  },
  {
    "title": "Tests: Integration (Controller/DB mocken) und E2E-Smoke",
    "prompt": "Ziel: Testabdeckung erhöhen zur Stabilität.\n\nAufgaben:\n- Integrationstests: Mock Controller-API und DB, prüfe Task-Flows.\n- E2E-Smoke im docker-compose up: Warte bis /ready ok, triggere eine Dummy-Task.\n\nAkzeptanzkriterien:\n- Tests laufen via run-tests.sh und in CI grün."
  },
  {
    "title": "Frontend-Resilienz: Fehlertolerante UI für Settings/DB-Ansichten",
    "prompt": "Ziel: UI-Komponenten robuster machen.\n\nAufgaben:\n- Füge Loading-/Error-States, Retry-Buttons und Timeout-Cancellation hinzu.\n- Zentralisiere API-Client mit Fetch-Retry und Timeout.\n- Zeige klare Nutzer-Hinweise bei Backend-Unverfügbarkeit.\n\nAkzeptanzkriterien:\n- UI friert nicht ein und informiert den Nutzer verständlich."
  },
  {
    "title": "Feature Flags und sichere Defaults",
    "prompt": "Ziel: Neue Features schrittweise aktivierbar machen.\n\nAufgaben:\n- Füge einfache Feature-Flag-Verwaltung in Settings (z.B. AI_AGENT_FEATURE_*) hinzu.\n- Umschließe riskante/neue Pfade (z.B. neuer HTTP-Client) mit Flags und setze stabile Defaults.\n\nAkzeptanzkriterien:\n- Flags können per ENV aktiviert werden; Default ist stabiler Pfad."
  },
  {
    "title": "Hub: Zentrales Agenten-Management & Auto-Discovery",
    "prompt": "Ziel: Der Hub soll als zentrales Verzeichnis für alle Agent-Instanzen dienen.\n\nAufgaben:\n- Implementiere einen /register (POST) Endpunkt im Hub, an dem sich Worker-Agenten beim Start anmelden.\n- Persistiere die Liste der aktiven Agenten (Name, URL, Rolle, Fähigkeiten) in der (zukünftigen) DB oder vorerst in agents.json.\n- Implementiere Health-Monitoring im Hub, das periodisch alle registrierten Agenten prüft.\n- Erweitere die Task-Zuweisung, sodass Agenten aus diesem Verzeichnis ausgewählt werden können.\n\nAkzeptanzkriterien:\n- Neue Agenten erscheinen automatisch im Dashboard, sobald sie gestartet werden.\n- Der Hub zeigt den Status (Online/Offline) aller bekannten Agenten an."
  },
  {
    "title": "Worker: Persistente Shell-Sessions für konsistente Terminal-Kontrolle",
    "prompt": "Ziel: Erhalt von Zuständen (Verzeichnisse, Umgebungsvariablen) über mehrere Befehlsschritte hinweg.\n\nAufgaben:\n- Ersetze subprocess.run durch eine langlebige Shell-Interaktion (z.B. via pexpect oder Hintergrund-Shell mit Pipes).\n- Implementiere Mechanismen zum Lesen von stdout/stderr in Echtzeit.\n- Stelle sicher, dass 'cd' Befehle den Pfad für nachfolgende Befehle ändern.\n\nAkzeptanzkriterien:\n- Ein 'cd /tmp' gefolgt von 'pwd' gibt '/tmp' zurück.\n- Terminal-Ausgaben werden während der Ausführung gestreamt (Vorbereitung für SSE)."
  },
  {
    "title": "Hub: Kontext-Management & Chat-History (Gedächtnis)",
    "prompt": "Ziel: Der Hub fungiert als Gedächtnis, indem er den Verlauf der Interaktionen pro Task speichert.\n\nAufgaben:\n- Erweitere das Task-Modell im Hub um ein 'history' Feld.\n- Speichere jeden Prompt, den vorgeschlagenen Befehl und das Ergebnis der Ausführung in dieser Historie.\n- Integriere die Historie in den Prompt-Konstruktor, damit das LLM weiß, was zuvor passiert ist.\n\nAkzeptanzkriterien:\n- Das LLM kann sich auf Ergebnisse früherer Befehle beziehen (z.B. 'Fixe den Fehler aus dem letzten Build-Versuch')."
  },
  {
    "title": "Frontend: Echtzeit-Terminal & Streaming-Logs",
    "prompt": "Ziel: Live-Visualisierung der Agenten-Aktivitäten im Dashboard.\n\nAufgaben:\n- Implementiere Server-Sent Events (SSE) oder Websockets im Hub/Worker zur Übertragung von Log-Streams.\n- Erstelle eine Terminal-Komponente in Angular (xterm.js oder simple Pre-Ansicht), die den Output live anzeigt.\n- Integriere diese Ansicht in das Agent-Panel und die Task-Detailansicht.\n\nAkzeptanzkriterien:\n- Nutzer sieht Terminal-Output sofort, ohne die Seite neu zu laden oder zu pollen."
  }
]
