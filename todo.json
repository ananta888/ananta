[
  {
    "title": "DB-Verbindungen: Pooling, robuste Fehlerbehandlung und Migrationspfad",
    "prompt": "Ziel: Stabileren DB-Zugriff sicherstellen.\n\nAufgaben:\n- Prüfe src/db/ und src/db_config.py: Implementiere Connection-Pooling (z.B. psycopg2.pool oder SQLAlchemy Engine).\n- Füge Retry bei transienten Fehlern hinzu.\n- Füge einfache Migrationen hinzu (z.B. Alembic) oder dokumentiere Migrationslauf.\n- Ergänze Health/Readiness um DB-Ping.\n\nAkzeptanzkriterien:\n- Langlebige Prozesse leaken keine Connections.\n- Simulierte DB-Neustarts werden abgefangen (Reconnect)."
  },
  {
    "title": "Observability: Prometheus-Metriken und optionale Traces",
    "prompt": "Ziel: Betriebsmetriken verfügbar machen.\n\nAufgaben:\n- Integriere prometheus_client und stelle /metrics bereit.\n- Metriken: task_received_total, task_completed_total, task_failed_total, http_request_duration_seconds nach Ziel, llm_call_duration_seconds, retries_total.\n- Optional: OpenTelemetry-Hooks für HTTP und DB (abschaltbar).\n\nAkzeptanzkriterien:\n- Metriken sind im Betrieb abrufbar; Basis-Grafana-Dashboard beschrieben."
  },
  {
    "title": "Input/Output-Validierung: Strikte Durchsetzung",
    "prompt": "Ziel: Stabilität durch Pydantic-Validierung in allen API-Endpunkten.\n\nAufgaben:\n- Nutze die in models.py definierten Pydantic-Modelle zur Validierung von Request-Body in Flask (z.B. via Decorator).\n- Stelle sicher, dass alle Controller-Antworten den Modellen entsprechen.\n\nAkzeptanzkriterien:\n- Ungültige Payloads werden mit 422 Unprocessable Entity abgelehnt."
  },
  {
    "title": "Fehlerstrategie und einheitliche Exception-Handling-Middleware",
    "prompt": "Ziel: Klare Fehlerklassifikation (transient vs. permanent) und einheitliche Behandlung.\n\nAufgaben:\n- Erstelle Fehlerklassen (TransientError, PermanentError).\n- Mapping: HTTP 5xx/Timeout -> Transient (mit Retry), 4xx valider Fehler -> Permanent.\n- Fange Ausnahmen zentral ab, logge strukturiert mit Ursache und Korrelation-ID.\n\nAkzeptanzkriterien:\n- Wiederholbare Fehler werden automatisch erneut versucht; permanente werden dokumentiert."
  },
  {
    "title": "Security: Secrets-Handling, Rate Limiting und Dependency-Scanning",
    "prompt": "Ziel: Basis-Security-Härte.\n\nAufgaben:\n- Lade Secrets nur aus ENV/Secret-Store; verhindere Log-Ausgabe sensibler Werte.\n- Implementiere einfaches Rate-Limiting auf kritischen Endpoints (falls extern exponiert).\n- Füge Safety Checks in CI (pip-audit, bandit).\n\nAkzeptanzkriterien:\n- Keine Secrets in Logs/Artefakten.\n- CI bricht bei bekannten kritischen CVEs."
  },
  {
    "title": "Tests: Integration (Controller/DB mocken) und E2E-Smoke",
    "prompt": "Ziel: Testabdeckung erhöhen zur Stabilität.\n\nAufgaben:\n- Integrationstests: Mock Controller-API und DB, prüfe Task-Flows.\n- E2E-Smoke im docker-compose up: Warte bis /ready ok, triggere eine Dummy-Task.\n\nAkzeptanzkriterien:\n- Tests laufen via run-tests.sh und in CI grün."
  },
  {
    "title": "Frontend-Resilienz: Fehlertolerante UI für Settings/DB-Ansichten",
    "prompt": "Ziel: UI-Komponenten robuster machen.\n\nAufgaben:\n- Füge Loading-/Error-States, Retry-Buttons und Timeout-Cancellation hinzu.\n- Zentralisiere API-Client mit Fetch-Retry und Timeout.\n- Zeige klare Nutzer-Hinweise bei Backend-Unverfügbarkeit.\n\nAkzeptanzkriterien:\n- UI friert nicht ein und informiert den Nutzer verständlich."
  },
  {
    "title": "Feature Flags und sichere Defaults",
    "prompt": "Ziel: Neue Features schrittweise aktivierbar machen.\n\nAufgaben:\n- Füge einfache Feature-Flag-Verwaltung in Settings (z.B. AI_AGENT_FEATURE_*) hinzu.\n- Umschließe riskante/neue Pfade (z.B. neuer HTTP-Client) mit Flags und setze stabile Defaults.\n\nAkzeptanzkriterien:\n- Flags können per ENV aktiviert werden; Default ist stabiler Pfad."
  },
  {
    "title": "Hub: Kontext-Management & Chat-History (Gedächtnis)",
    "prompt": "Ziel: Der Hub fungiert als Gedächtnis, indem er den Verlauf der Interaktionen pro Task speichert.\n\nAufgaben:\n- Erweitere das Task-Modell im Hub um ein 'history' Feld.\n- Speichere jeden Prompt, den vorgeschlagenen Befehl und das Ergebnis der Ausführung in dieser Historie.\n- Integriere die Historie in den Prompt-Konstruktor, damit das LLM weiß, was zuvor passiert ist.\n\nAkzeptanzkriterien:\n- Das LLM kann sich auf Ergebnisse früherer Befehle beziehen (z.B. 'Fixe den Fehler aus dem letzten Build-Versuch')."
  },
  {
    "title": "Frontend: Echtzeit-Terminal & Streaming-Logs",
    "prompt": "Ziel: Live-Visualisierung der Agenten-Aktivitäten im Dashboard.\n\nAufgaben:\n- Implementiere Server-Sent Events (SSE) oder Websockets im Hub/Worker zur Übertragung von Log-Streams.\n- Erstelle eine Terminal-Komponente in Angular (xterm.js oder simple Pre-Ansicht), die den Output live anzeigt.\n- Integriere diese Ansicht in das Agent-Panel und die Task-Detailansicht.\n\nAkzeptanzkriterien:\n- Nutzer sieht Terminal-Output sofort, ohne die Seite neu zu laden oder zu pollen."
  },
  {
    "title": "Hub: Task-Verteilung & Load Balancing",
    "prompt": "Ziel: Der Hub soll Tasks intelligent auf verfügbare Worker verteilen.\n\nAufgaben:\n- Implementiere eine Strategie zur Task-Zuweisung (z.B. Round-Robin oder Least-Busy).\n- Nutze die Liste der registrierten Agenten aus /agents für die Zuweisung.\n\nAkzeptanzkriterien:\n- Tasks werden automatisch an einen 'online' Worker delegiert."
  },
  {
    "title": "Refactoring: Einheitliche HTTP-Client Nutzung",
    "prompt": "Ziel: Alle ausgehenden HTTP-Anfragen sollen über den robusten http_client Wrapper laufen.\n\nAufgaben:\n- Ersetze direkte 'requests.post' und 'requests.get' Aufrufe in ai_agent.py durch _http_post und _http_get.\n- Stelle sicher, dass Timeouts und Retries überall greifen.\n\nAkzeptanzkriterien:\n- Keine direkten 'requests' Importe außerhalb von common/http.py nötig."
  }
]
