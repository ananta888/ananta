{
  "qa-2026-02-16-test-thread-lifecycle-for-llm-monitoring": {
    "id": "qa-2026-02-16-test-thread-lifecycle-for-llm-monitoring",
    "title": "Testlauf: LLM-Monitoring-Thread sauber beenden um Logging-Fehler zu vermeiden",
    "status": "todo",
    "priority": "low",
    "rank": 1,
    "type": "qa",
    "details": "In Testlaeufen treten nach erfolgreichem pytest Logging-Fehler aus Hintergrundthreads auf (I/O operation on closed file). Noetig: kontrollierter Thread-Lifecycle oder Test-Guard, damit Monitoring-Threads in Tests nicht nach Prozessende weiterloggen.",
    "observed_at": "2026-02-16"
  },
  "fe-2026-02-16-quality-gates-dedicated-settings-page": {
    "id": "fe-2026-02-16-quality-gates-dedicated-settings-page",
    "title": "Quality-Gates aus Dashboard in dedizierte Settings-Seite ueberfuehren",
    "status": "todo",
    "priority": "low",
    "rank": 2,
    "type": "ux",
    "details": "Quality-Gates sind jetzt editierbar, liegen aber im Dashboard-Block. Fuer bessere Auffindbarkeit und Rollenabgrenzung sollte die Konfiguration in den Settings-Bereich mit valider Formularstruktur und Hilfe-Texten verschoben werden.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-task-status-filter-query-normalization-with-db-support": {
    "id": "backend-2026-02-16-task-status-filter-query-normalization-with-db-support",
    "title": "Statusfilter mit Alias-Normalisierung direkt auf DB-Query-Ebene abbilden",
    "status": "todo",
    "priority": "low",
    "rank": 3,
    "type": "backend",
    "details": "Der Statusfilter ist funktional normalisiert, nutzt bei gesetztem Status derzeit einen In-Memory-Filter ueber alle Tasks. Fuer groessere Taskmengen sollte das Alias-Mapping SQL-seitig (WHERE IN / normalisierte Spalte) umgesetzt werden.",
    "observed_at": "2026-02-16"
  },
  "fe-2026-02-16-extract-shared-task-status-normalizer-for-components": {
    "id": "fe-2026-02-16-extract-shared-task-status-normalizer-for-components",
    "title": "Gemeinsamen Task-Status-Normalizer fuer UI-Komponenten extrahieren",
    "status": "todo",
    "priority": "low",
    "rank": 4,
    "type": "fe",
    "details": "Status-Normalisierung wird aktuell in mehreren Komponenten lokal wiederholt (Board/Task-Detail/Task-Graph). Ein shared Helper/Service reduziert Duplikate und verhindert Drift bei kuenftigen Statusaenderungen.",
    "observed_at": "2026-02-16"
  },
  "sec-2026-02-16-tool-guardrail-observability-in-task-history-and-ui": {
    "id": "sec-2026-02-16-tool-guardrail-observability-in-task-history-and-ui",
    "title": "Guardrail-Entscheidungen in Task-History und UI sichtbar machen",
    "status": "todo",
    "priority": "low",
    "rank": 5,
    "type": "sec",
    "details": "Tool-Guardrails blockieren nun zentral, aber die Detailmetrik (Klassenzaehler, Kostenbudget) ist prim√§r API-seitig. Fuer Betrieb sollte eine explizite Darstellung in Task-History/Timeline und UI-Badges erfolgen.",
    "observed_at": "2026-02-16"
  },
  "sec-2026-02-16-token-budget-guardrail-for-llm-tool-workflows": {
    "id": "sec-2026-02-16-token-budget-guardrail-for-llm-tool-workflows",
    "title": "Tokenbudget-Guardrail fuer LLM-Tool-Workflows ergaenzen",
    "status": "todo",
    "priority": "low",
    "rank": 6,
    "type": "sec",
    "details": "Kostenbudget wird aktuell als heuristische Cost-Units pro Tool-Klasse berechnet. Fuer praezisere Budgetsteuerung sollte ein echtes Tokenbudget (Prompt/Completion) pro Request/Task integriert und auditiert werden.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-unify-config-unwrapping-with-common-envelope-helper": {
    "id": "backend-2026-02-16-unify-config-unwrapping-with-common-envelope-helper",
    "title": "Config-Unwrapping mit gemeinsamem Envelope-Helper vereinheitlichen",
    "status": "todo",
    "priority": "low",
    "rank": 7,
    "type": "backend",
    "details": "Fuer Task- und Worker-Responses gibt es nun einen zentralen Envelope-Helper. In config.py existiert weiterhin ein separater unwrap_config-Pfad. Vereinheitlichung reduziert Sonderfaelle und Wartungsaufwand.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-circuit-breaker-events-in-task-timeline": {
    "id": "backend-2026-02-16-circuit-breaker-events-in-task-timeline",
    "title": "Circuit-Open/Reset Events in Task-Timeline integrieren",
    "status": "todo",
    "priority": "low",
    "rank": 8,
    "type": "backend",
    "details": "Circuit-Status und Admin-Reset sind nun per API sichtbar. Fuer durchgaengige Nachvollziehbarkeit sollten Circuit-Open/Close/Reset Ereignisse zusaetzlich als Timeline-/Audit-Events mit Worker-Bezug erfasst werden.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-schema-compat-migrations-parity-with-alembic": {
    "id": "backend-2026-02-16-schema-compat-migrations-parity-with-alembic",
    "title": "Schema-Compat-Migrationen mit Alembic-Migrationsstand synchronisieren",
    "status": "todo",
    "priority": "low",
    "rank": 9,
    "type": "backend",
    "details": "Startup-Compat-Migrationen decken nun depends_on und MFA-Spalte ab. Zur langfristigen Wartbarkeit sollte eine klare Paritaet mit offiziellen Alembic-Migrationen hergestellt und dokumentiert werden, um doppelte/abweichende Migrationspfade zu vermeiden.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-security-policy-configurable-via-agent-config": {
    "id": "backend-2026-02-16-security-policy-configurable-via-agent-config",
    "title": "Security-Level-Policies in AGENT_CONFIG konfigurierbar machen",
    "status": "todo",
    "priority": "low",
    "rank": 10,
    "type": "backend",
    "details": "Security-Level-Enforcement ist aktiv (Tool-Klassen + Concurrency/Timeout/Retry). Aktuell sind Policy-Werte im Code hinterlegt. Fuer Betrieb sollte das Mapping je Level zentral in AGENT_CONFIG editierbar sein.",
    "observed_at": "2026-02-16"
  }
}
