{
  "sec-2026-02-16-tool-class-external-call-and-cost-budgets": {
    "id": "sec-2026-02-16-tool-class-external-call-and-cost-budgets",
    "title": "Guardrails auf Tool-Klassen, externe Calls und Kostenbudgets erweitern",
    "status": "todo",
    "priority": "medium",
    "rank": 1,
    "type": "sec",
    "details": "Basis-Guardrails fuer Laufzeit/Ticks/Dispatch sind aktiv. Es fehlen noch harte Limits je Tool-Klasse, Outbound-Call-Budgets und Kosten-/Token-Budgets mit zentraler Durchsetzung und sauberem Audit-Eintrag bei Verletzung.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-api-envelope-unwrapping-robustness": {
    "id": "backend-2026-02-16-api-envelope-unwrapping-robustness",
    "title": "API-Response-Unwrapping robuster fuer gemischte Envelope-Formate machen",
    "status": "todo",
    "priority": "low",
    "rank": 2,
    "type": "backend",
    "details": "Interne Calls liefern teils {data}-Payloads ohne status/code. Das aktuelle Unwrapping ist uneinheitlich und kann zu impliziten Fehlern bei Autopilot-Entscheidungen fuehren. Einheitliches robustes Normalisieren plus Tests ergaenzen.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-circuit-breaker-observability-and-admin-reset": {
    "id": "backend-2026-02-16-circuit-breaker-observability-and-admin-reset",
    "title": "Circuit-Breaker-Status sichtbar machen und Admin-Reset ergaenzen",
    "status": "todo",
    "priority": "medium",
    "rank": 3,
    "type": "backend",
    "details": "Retry/Breaker sind implementiert, aber nicht transparent genug. Noetig: sichtbare Worker-Circuit-Zustaende in Status/API/Timeline sowie optionaler Admin-Reset fuer geoeffnete Circuits.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-db-migration-for-task-depends-on": {
    "id": "backend-2026-02-16-db-migration-for-task-depends-on",
    "title": "DB-Migration fuer neues Task-Feld depends_on[] bereitstellen",
    "status": "todo",
    "priority": "medium",
    "rank": 4,
    "type": "backend",
    "details": "Das Feld depends_on[] ist nun im Modell aktiv. Fuer bestehende produktive Datenbanken muss eine saubere Migration/Backfill inkl. Rollout-Hinweis ergaenzt werden, damit Deployments ohne Schema-Drift laufen.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-security-level-policy-enforcement": {
    "id": "backend-2026-02-16-security-level-policy-enforcement",
    "title": "Autopilot security_level backendseitig in echte Policy uebersetzen",
    "status": "todo",
    "priority": "medium",
    "rank": 5,
    "type": "backend",
    "details": "Goal/Team/Budget/Security-Level werden jetzt persistiert, aber security_level steuert noch keine konkrete Laufzeit-Policy. Noetig: Mapping auf Guardrails/Tool-Allowlist/Execution-Limits inkl. transparenter Statusanzeige.",
    "observed_at": "2026-02-16"
  },
  "qa-2026-02-16-test-thread-lifecycle-for-llm-monitoring": {
    "id": "qa-2026-02-16-test-thread-lifecycle-for-llm-monitoring",
    "title": "Testlauf: LLM-Monitoring-Thread sauber beenden um Logging-Fehler zu vermeiden",
    "status": "todo",
    "priority": "low",
    "rank": 6,
    "type": "qa",
    "details": "In Testlaeufen treten nach erfolgreichem pytest Logging-Fehler aus Hintergrundthreads auf (I/O operation on closed file). Noetig: kontrollierter Thread-Lifecycle oder Test-Guard, damit Monitoring-Threads in Tests nicht nach Prozessende weiterloggen.",
    "observed_at": "2026-02-16"
  },
  "fe-2026-02-16-quality-gates-dedicated-settings-page": {
    "id": "fe-2026-02-16-quality-gates-dedicated-settings-page",
    "title": "Quality-Gates aus Dashboard in dedizierte Settings-Seite ueberfuehren",
    "status": "todo",
    "priority": "low",
    "rank": 7,
    "type": "ux",
    "details": "Quality-Gates sind jetzt editierbar, liegen aber im Dashboard-Block. Fuer bessere Auffindbarkeit und Rollenabgrenzung sollte die Konfiguration in den Settings-Bereich mit valider Formularstruktur und Hilfe-Texten verschoben werden.",
    "observed_at": "2026-02-16"
  },
  "backend-2026-02-16-task-status-filter-query-normalization-with-db-support": {
    "id": "backend-2026-02-16-task-status-filter-query-normalization-with-db-support",
    "title": "Statusfilter mit Alias-Normalisierung direkt auf DB-Query-Ebene abbilden",
    "status": "todo",
    "priority": "low",
    "rank": 8,
    "type": "backend",
    "details": "Der Statusfilter ist funktional normalisiert, nutzt bei gesetztem Status derzeit einen In-Memory-Filter ueber alle Tasks. Fuer groessere Taskmengen sollte das Alias-Mapping SQL-seitig (WHERE IN / normalisierte Spalte) umgesetzt werden.",
    "observed_at": "2026-02-16"
  },
  "fe-2026-02-16-extract-shared-task-status-normalizer-for-components": {
    "id": "fe-2026-02-16-extract-shared-task-status-normalizer-for-components",
    "title": "Gemeinsamen Task-Status-Normalizer fuer UI-Komponenten extrahieren",
    "status": "todo",
    "priority": "low",
    "rank": 9,
    "type": "fe",
    "details": "Status-Normalisierung wird aktuell in mehreren Komponenten lokal wiederholt (Board/Task-Detail/Task-Graph). Ein shared Helper/Service reduziert Duplikate und verhindert Drift bei kuenftigen Statusaenderungen.",
    "observed_at": "2026-02-16"
  }
}
